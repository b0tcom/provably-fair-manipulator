// provably_fair_exploiter.js
// For authorized testing/verification only!

/**
 * Loads the seedrandom library from CDN if not already loaded.
 * Calls the callback once seedrandom is ready.
 */
function loadSeedrandom(callback) {
  if (typeof seedrandom === 'function') {
    callback();
  } else {
    var script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js';
    script.onload = callback;
    document.head.appendChild(script);
  }
}

loadSeedrandom(function() {
  /**
   * ProvablyFairExploiter provides deterministic case battle outcome simulation
   * for security testing, audit, or transparency use.
   */
  class ProvablyFairExploiter {
    /**
     * Simulates the full case battle outcome, ticket-by-ticket, using the battle logic.
     * @param {string} serverSeed - The server seed to use.
     * @param {number} rounds - Number of rounds (cases) in the battle.
     * @param {string} type - Battle type ('1vs1', '1vs1vs1', '2vs2', or '3vs3').
     * @param {boolean} isOld - True for the 'old' battle algorithm, false for new (default: false).
     * @returns {object} - {results: Array<{round, tickets}>, tieTicket: number}
     */
    simulateCaseBattle(serverSeed, rounds, type, isOld = false) {
      const slots = {
        '1vs1': 2,
        '1vs1vs1': 3,
        '2vs2': 4,
        '3vs3': 6
      }[type];

      if (!slots) {
        console.log("Invalid case battle type");
        return [];
      }

      const results = [];
      for (let round = 0; round < rounds; round++) {
        const roundTickets = [];
        for (let slot = 1; slot <= slots; slot++) {
          const seed = isOld
            ? `${serverSeed}:${round + 1}:${round + 1}:${slot}`
            : `${serverSeed}:${round + 1}:${slot}`;
          const rollNumber = seedrandom(seed)();
          const ticket = Math.floor(rollNumber * 100000);
          roundTickets.push(ticket);
        }
        results.push({ round: round + 1, tickets: roundTickets });
      }
      // Tie ticket (for tie-breaking logic)
      const tieTicket = seedrandom(serverSeed)();
      return { results, tieTicket };
    }

    /**
     * Predicts outcomes for multiple possible server seeds, bulk mode.
     * @param {Array<string>} candidateSeeds - Array of server seeds.
     * @param {number} rounds
     * @param {string} type
     * @param {boolean} isOld
     * @returns {object} - Mapping from seed to simulation result.
     */
    predictOutcomeForAllSeeds(candidateSeeds, rounds, type, isOld = false) {
      const predictions = {};
      candidateSeeds.forEach(seed => {
        predictions[seed] = this.simulateCaseBattle(seed, rounds, type, isOld);
      });
      return predictions;
    }
  }

  window.ProvablyFairExploiter = ProvablyFairExploiter;

  console.log(`
== Provably Fair Exploiter READY ==
1. Create exploiter:    const exploiter = new ProvablyFairExploiter();
2. Run battle sim:      exploiter.simulateCaseBattle(serverSeed, rounds, type, isOld);
   - e.g. exploiter.simulateCaseBattle('abc123', 10, '2vs2', false)
3. Batch predict:       exploiter.predictOutcomeForAllSeeds(['seed1','seed2'], rounds, type, isOld);
   - Returns mapping of each seed to full battle ticket simulation.
4. All output is in browser console as objects/arrays for your review.
`);
});
